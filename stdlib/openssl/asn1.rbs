# Abstract Syntax Notation One (or ASN.1) is a notation syntax to describe data
# structures and is defined in ITU-T X.680. ASN.1 itself does not mandate any
# encoding or parsing rules, but usually ASN.1 data structures are encoded using
# the Distinguished Encoding Rules (DER) or less often the Basic Encoding Rules
# (BER) described in ITU-T X.690. DER and BER encodings are binary
# Tag-Length-Value (TLV) encodings that are quite concise compared to other
# popular data description formats such as XML, JSON etc. ASN.1 data structures
# are very common in cryptographic applications, e.g. X.509 public key
# certificates or certificate revocation lists (CRLs) are all defined in ASN.1
# and DER-encoded. ASN.1, DER and BER are the building blocks of applied
# cryptography. The ASN1 module provides the necessary classes that allow
# generation of ASN.1 data structures and the methods to encode them using a DER
# encoding. The decode method allows parsing arbitrary BER-/DER-encoded data to
# a Ruby object that can then be modified and re-encoded at will.
#
# ## ASN.1 class hierarchy
#
# The base class representing ASN.1 structures is ASN1Data. ASN1Data offers
# attributes to read and set the *tag*, the *tag_class* and finally the *value*
# of a particular ASN.1 item. Upon parsing, any tagged values (implicit or
# explicit) will be represented by ASN1Data instances because their "real type"
# can only be determined using out-of-band information from the ASN.1 type
# declaration. Since this information is normally known when encoding a type,
# all sub-classes of ASN1Data offer an additional attribute *tagging* that
# allows to encode a value implicitly (`:IMPLICIT`) or explicitly (`:EXPLICIT`).
#
# ### Constructive
#
# Constructive is, as its name implies, the base class for all constructed
# encodings, i.e. those that consist of several values, opposed to "primitive"
# encodings with just one single value. The value of an Constructive is always
# an Array.
#
# #### ASN1::Set and ASN1::Sequence
#
# The most common constructive encodings are SETs and SEQUENCEs, which is why
# there are two sub-classes of Constructive representing each of them.
#
# ### Primitive
#
# This is the super class of all primitive values. Primitive itself is not used
# when parsing ASN.1 data, all values are either instances of a corresponding
# sub-class of Primitive or they are instances of ASN1Data if the value was
# tagged implicitly or explicitly. Please cf. Primitive documentation for
# details on sub-classes and their respective mappings of ASN.1 data types to
# Ruby objects.
#
# ## Possible values for *tagging*
#
# When constructing an ASN1Data object the ASN.1 type definition may require
# certain elements to be either implicitly or explicitly tagged. This can be
# achieved by setting the *tagging* attribute manually for sub-classes of
# ASN1Data. Use the symbol `:IMPLICIT` for implicit tagging and `:EXPLICIT` if
# the element requires explicit tagging.
#
type OpenSSL::ASN1::tagging = :IMPLICIT | :EXPLICIT

# ## Possible values for *tag_class*
#
# It is possible to create arbitrary ASN1Data objects that also support a
# PRIVATE or APPLICATION tag class. Possible values for the *tag_class*
# attribute are:
# *   `:UNIVERSAL` (the default for untagged values)
# *   `:CONTEXT_SPECIFIC` (the default for tagged values)
# *   `:APPLICATION`
# *   `:PRIVATE`
#
#
type OpenSSL::ASN1::tag_class = :UNIVERSAL | :CONTEXT_SPECIFIC | :APPLICATION | :PRIVATE

# ## Tag constants
#
# There is a constant defined for each universal tag:
# *   OpenSSL::ASN1::EOC (0)
# *   OpenSSL::ASN1::BOOLEAN (1)
# *   OpenSSL::ASN1::INTEGER (2)
# *   OpenSSL::ASN1::BIT_STRING (3)
# *   OpenSSL::ASN1::OCTET_STRING (4)
# *   OpenSSL::ASN1::NULL (5)
# *   OpenSSL::ASN1::OBJECT (6)
# *   OpenSSL::ASN1::ENUMERATED (10)
# *   OpenSSL::ASN1::UTF8STRING (12)
# *   OpenSSL::ASN1::SEQUENCE (16)
# *   OpenSSL::ASN1::SET (17)
# *   OpenSSL::ASN1::NUMERICSTRING (18)
# *   OpenSSL::ASN1::PRINTABLESTRING (19)
# *   OpenSSL::ASN1::T61STRING (20)
# *   OpenSSL::ASN1::VIDEOTEXSTRING (21)
# *   OpenSSL::ASN1::IA5STRING (22)
# *   OpenSSL::ASN1::UTCTIME (23)
# *   OpenSSL::ASN1::GENERALIZEDTIME (24)
# *   OpenSSL::ASN1::GRAPHICSTRING (25)
# *   OpenSSL::ASN1::ISO64STRING (26)
# *   OpenSSL::ASN1::GENERALSTRING (27)
# *   OpenSSL::ASN1::UNIVERSALSTRING (28)
# *   OpenSSL::ASN1::BMPSTRING (30)
#
#
# ## UNIVERSAL_TAG_NAME constant
#
# An Array that stores the name of a given tag number. These names are the same
# as the name of the tag constant that is additionally defined, e.g.
# [UNIVERSAL_TAG_NAME](2) = "INTEGER" and OpenSSL::ASN1::INTEGER = 2.
#
# ## Example usage
#
# ### Decoding and viewing a DER-encoded file
#     require 'openssl'
#     require 'pp'
#     der = File.binread('data.der')
#     asn1 = OpenSSL::ASN1.decode(der)
#     pp der
#
# ### Creating an ASN.1 structure and DER-encoding it
#     require 'openssl'
#     version = OpenSSL::ASN1::Integer.new(1)
#     # Explicitly 0-tagged implies context-specific tag class
#     serial = OpenSSL::ASN1::Integer.new(12345, 0, :EXPLICIT, :CONTEXT_SPECIFIC)
#     name = OpenSSL::ASN1::PrintableString.new('Data 1')
#     sequence = OpenSSL::ASN1::Sequence.new( [ version, serial, name ] )
#     der = sequence.to_der
#
module OpenSSL::ASN1
  def self.BMPString: (String value, ?Integer tag, ?OpenSSL::ASN1::tagging tagging, ?OpenSSL::ASN1::tag_class tag_class) -> OpenSSL::ASN1::BMPString

  def self.BitString: (String value, ?Integer tag, ?OpenSSL::ASN1::tagging tagging, ?OpenSSL::ASN1::tag_class tag_class) -> OpenSSL::ASN1::BitString

  def self.Boolean: (bool value, ?Integer tag, ?OpenSSL::ASN1::tagging tagging, ?OpenSSL::ASN1::tag_class tag_class) -> OpenSSL::ASN1::Boolean

  def self.EndOfContent: () -> OpenSSL::ASN1::EndOfContent

  def self.Enumerated: (Integer value, ?Integer tag, ?OpenSSL::ASN1::tagging tagging, ?OpenSSL::ASN1::tag_class tag_class) -> OpenSSL::ASN1::Enumerated

  def self.GeneralString: (String value, ?Integer tag, ?OpenSSL::ASN1::tagging tagging, ?OpenSSL::ASN1::tag_class tag_class) -> OpenSSL::ASN1::GeneralString

  def self.GeneralizedTime: (Time value, ?Integer tag, ?OpenSSL::ASN1::tagging tagging, ?OpenSSL::ASN1::tag_class tag_class) -> OpenSSL::ASN1::GeneralizedTime

  def self.GraphicString: (String value, ?Integer tag, ?OpenSSL::ASN1::tagging tagging, ?OpenSSL::ASN1::tag_class tag_class) -> OpenSSL::ASN1::GraphicString

  def self.IA5String: (String value, ?Integer tag, ?OpenSSL::ASN1::tagging tagging, ?OpenSSL::ASN1::tag_class tag_class) -> OpenSSL::ASN1::IA5String

  def self.ISO64String: (String value, ?Integer tag, ?OpenSSL::ASN1::tagging tagging, ?OpenSSL::ASN1::tag_class tag_class) -> OpenSSL::ASN1::ISO64String

  def self.Integer: (OpenSSL::BN value, ?Integer tag, ?OpenSSL::ASN1::tagging tagging, ?OpenSSL::ASN1::tag_class tag_class) -> OpenSSL::ASN1::Integer

  def self.Null: (nil value, ?Integer tag, ?OpenSSL::ASN1::tagging tagging, ?OpenSSL::ASN1::tag_class tag_class) -> OpenSSL::ASN1::Null

  def self.NumericString: (String value, ?Integer tag, ?OpenSSL::ASN1::tagging tagging, ?OpenSSL::ASN1::tag_class tag_class) -> OpenSSL::ASN1::NumericString

  def self.ObjectId: (String value, ?Integer tag, ?OpenSSL::ASN1::tagging tagging, ?OpenSSL::ASN1::tag_class tag_class) -> OpenSSL::ASN1::ObjectId

  def self.OctetString: (String value, ?Integer tag, ?OpenSSL::ASN1::tagging tagging, ?OpenSSL::ASN1::tag_class tag_class) -> OpenSSL::ASN1::OctetString

  def self.PrintableString: (String value, ?Integer tag, ?OpenSSL::ASN1::tagging tagging, ?OpenSSL::ASN1::tag_class tag_class) -> OpenSSL::ASN1::PrintableString

  def self.Sequence: (Array[OpenSSL::ASN1::ASN1Data] value, ?Integer tag, ?OpenSSL::ASN1::tagging tagging, ?OpenSSL::ASN1::tag_class tag_class) -> OpenSSL::ASN1::Sequence

  def self.Set: (Array[OpenSSL::ASN1::ASN1Data] value, ?Integer tag, ?OpenSSL::ASN1::tagging tagging, ?OpenSSL::ASN1::tag_class tag_class) -> OpenSSL::ASN1::Set

  def self.T61String: (String value, ?Integer tag, ?OpenSSL::ASN1::tagging tagging, ?OpenSSL::ASN1::tag_class tag_class) -> OpenSSL::ASN1::T61String

  def self.UTCTime: (Time value, ?Integer tag, ?OpenSSL::ASN1::tagging tagging, ?OpenSSL::ASN1::tag_class tag_class) -> OpenSSL::ASN1::UTCTime

  def self.UTF8String: (String value, ?Integer tag, ?OpenSSL::ASN1::tagging tagging, ?OpenSSL::ASN1::tag_class tag_class) -> OpenSSL::ASN1::UTF8String

  def self.UniversalString: (String value, ?Integer tag, ?OpenSSL::ASN1::tagging tagging, ?OpenSSL::ASN1::tag_class tag_class) -> OpenSSL::ASN1::UniversalString

  def self.VideotexString: (String value, ?Integer tag, ?OpenSSL::ASN1::tagging tagging, ?OpenSSL::ASN1::tag_class tag_class) -> OpenSSL::ASN1::VideotexString

  # Decodes a BER- or DER-encoded value and creates an ASN1Data instance. *der*
  # may be a String or any object that features a `.to_der` method transforming it
  # into a BER-/DER-encoded String+
  #
  # ## Example
  #     der = File.binread('asn1data')
  #     asn1 = OpenSSL::ASN1.decode(der)
  #
  def self.decode: (String | OpenSSL::_ToDer) -> OpenSSL::ASN1::ASN1Data

  # Similar to #decode with the difference that #decode expects one distinct value
  # represented in *der*. #decode_all on the contrary decodes a sequence of
  # sequential BER/DER values lined up in *der* and returns them as an array.
  #
  # ## Example
  #     ders = File.binread('asn1data_seq')
  #     asn1_ary = OpenSSL::ASN1.decode_all(ders)
  #
  def self.decode_all: (String | OpenSSL::_ToDer) -> Array[OpenSSL::ASN1::ASN1Data]

  # If a block is given, it prints out each of the elements encountered. Block
  # parameters are (in that order):
  # *   depth: The recursion depth, plus one with each constructed value being
  #     encountered (Integer)
  # *   offset: Current byte offset (Integer)
  # *   header length: Combined length in bytes of the Tag and Length headers.
  #     (Integer)
  # *   length: The overall remaining length of the entire data (Integer)
  # *   constructed: Whether this value is constructed or not (Boolean)
  # *   tag_class: Current tag class (Symbol)
  # *   tag: The current tag number (Integer)
  #
  #
  # ## Example
  #     der = File.binread('asn1data.der')
  #     OpenSSL::ASN1.traverse(der) do | depth, offset, header_len, length, constructed, tag_class, tag|
  #       puts "Depth: #{depth} Offset: #{offset} Length: #{length}"
  #       puts "Header length: #{header_len} Tag: #{tag} Tag class: #{tag_class} Constructed: #{constructed}"
  #     end
  #
  def self.traverse: (String | OpenSSL::_ToDer) { ([::Integer, ::Integer, ::Integer, ::Integer, bool, OpenSSL::ASN1::tag_class, ::Integer]) -> void } -> void
end

OpenSSL::ASN1::BIT_STRING: ::Integer

OpenSSL::ASN1::BMPSTRING: ::Integer

OpenSSL::ASN1::BOOLEAN: ::Integer

OpenSSL::ASN1::CHARACTER_STRING: ::Integer

OpenSSL::ASN1::EMBEDDED_PDV: ::Integer

OpenSSL::ASN1::ENUMERATED: ::Integer

OpenSSL::ASN1::EOC: ::Integer

OpenSSL::ASN1::EXTERNAL: ::Integer

OpenSSL::ASN1::GENERALIZEDTIME: ::Integer

OpenSSL::ASN1::GENERALSTRING: ::Integer

OpenSSL::ASN1::GRAPHICSTRING: ::Integer

OpenSSL::ASN1::IA5STRING: ::Integer

OpenSSL::ASN1::INTEGER: ::Integer

OpenSSL::ASN1::ISO64STRING: ::Integer

OpenSSL::ASN1::NULL: ::Integer

OpenSSL::ASN1::NUMERICSTRING: ::Integer

OpenSSL::ASN1::OBJECT: ::Integer

OpenSSL::ASN1::OBJECT_DESCRIPTOR: ::Integer

OpenSSL::ASN1::OCTET_STRING: ::Integer

OpenSSL::ASN1::PRINTABLESTRING: ::Integer

OpenSSL::ASN1::REAL: ::Integer

OpenSSL::ASN1::RELATIVE_OID: ::Integer

OpenSSL::ASN1::SEQUENCE: ::Integer

OpenSSL::ASN1::SET: ::Integer

OpenSSL::ASN1::T61STRING: ::Integer

OpenSSL::ASN1::UNIVERSALSTRING: ::Integer

# Array storing tag names at the tag's index.
#
OpenSSL::ASN1::UNIVERSAL_TAG_NAME: Array

OpenSSL::ASN1::UTCTIME: ::Integer

OpenSSL::ASN1::UTF8STRING: ::Integer

OpenSSL::ASN1::VIDEOTEXSTRING: ::Integer

# The top-level class representing any ASN.1 object. When parsed by ASN1.decode,
# tagged values are always represented by an instance of ASN1Data.
#
# ## The role of ASN1Data for parsing tagged values
#
# When encoding an ASN.1 type it is inherently clear what original type (e.g.
# INTEGER, OCTET STRING etc.) this value has, regardless of its tagging. But
# opposed to the time an ASN.1 type is to be encoded, when parsing them it is
# not possible to deduce the "real type" of tagged values. This is why tagged
# values are generally parsed into ASN1Data instances, but with a different
# outcome for implicit and explicit tagging.
#
# ### Example of a parsed implicitly tagged value
#
# An implicitly 1-tagged INTEGER value will be parsed as an ASN1Data with
# *   *tag* equal to 1
# *   *tag_class* equal to `:CONTEXT_SPECIFIC`
# *   *value* equal to a String that carries the raw encoding of the INTEGER.
#
# This implies that a subsequent decoding step is required to completely decode
# implicitly tagged values.
#
# ### Example of a parsed explicitly tagged value
#
# An explicitly 1-tagged INTEGER value will be parsed as an ASN1Data with
# *   *tag* equal to 1
# *   *tag_class* equal to `:CONTEXT_SPECIFIC`
# *   *value* equal to an Array with one single element, an instance of
#     OpenSSL::ASN1::Integer, i.e. the inner element is the non-tagged primitive
#     value, and the tagging is represented in the outer ASN1Data
#
#
# ## Example - Decoding an implicitly tagged INTEGER
#     int = OpenSSL::ASN1::Integer.new(1, 0, :IMPLICIT) # implicit 0-tagged
#     seq = OpenSSL::ASN1::Sequence.new( [int] )
#     der = seq.to_der
#     asn1 = OpenSSL::ASN1.decode(der)
#     # pp asn1 => #<OpenSSL::ASN1::Sequence:0x87326e0
#     #              @indefinite_length=false,
#     #              @tag=16,
#     #              @tag_class=:UNIVERSAL,
#     #              @tagging=nil,
#     #              @value=
#     #                [#<OpenSSL::ASN1::ASN1Data:0x87326f4
#     #                   @indefinite_length=false,
#     #                   @tag=0,
#     #                   @tag_class=:CONTEXT_SPECIFIC,
#     #                   @value="\x01">]>
#     raw_int = asn1.value[0]
#     # manually rewrite tag and tag class to make it an UNIVERSAL value
#     raw_int.tag = OpenSSL::ASN1::INTEGER
#     raw_int.tag_class = :UNIVERSAL
#     int2 = OpenSSL::ASN1.decode(raw_int)
#     puts int2.value # => 1
#
# ## Example - Decoding an explicitly tagged INTEGER
#     int = OpenSSL::ASN1::Integer.new(1, 0, :EXPLICIT) # explicit 0-tagged
#     seq = OpenSSL::ASN1::Sequence.new( [int] )
#     der = seq.to_der
#     asn1 = OpenSSL::ASN1.decode(der)
#     # pp asn1 => #<OpenSSL::ASN1::Sequence:0x87326e0
#     #              @indefinite_length=false,
#     #              @tag=16,
#     #              @tag_class=:UNIVERSAL,
#     #              @tagging=nil,
#     #              @value=
#     #                [#<OpenSSL::ASN1::ASN1Data:0x87326f4
#     #                   @indefinite_length=false,
#     #                   @tag=0,
#     #                   @tag_class=:CONTEXT_SPECIFIC,
#     #                   @value=
#     #                     [#<OpenSSL::ASN1::Integer:0x85bf308
#     #                        @indefinite_length=false,
#     #                        @tag=2,
#     #                        @tag_class=:UNIVERSAL
#     #                        @tagging=nil,
#     #                        @value=1>]>]>
#     int2 = asn1.value[0].value[0]
#     puts int2.value # => 1
#
class OpenSSL::ASN1::ASN1Data
  public

  # Never `nil`. A boolean value indicating whether the encoding uses indefinite
  # length (in the case of parsing) or whether an indefinite length form shall be
  # used (in the encoding case). In DER, every value uses definite length form.
  # But in scenarios where large amounts of data need to be transferred it might
  # be desirable to have some kind of streaming support available. For example,
  # huge OCTET STRINGs are preferably sent in smaller-sized chunks, each at a
  # time. This is possible in BER by setting the length bytes of an encoding to
  # zero and by this indicating that the following value will be sent in chunks.
  # Indefinite length encodings are always constructed. The end of such a stream
  # of chunks is indicated by sending a EOC (End of Content) tag. SETs and
  # SEQUENCEs may use an indefinite length encoding, but also primitive types such
  # as e.g. OCTET STRINGS or BIT STRINGS may leverage this functionality (cf.
  # ITU-T X.690).
  #
  def indefinite_length: () -> bool

  def indefinite_length=: (bool) -> void

  # Never `nil`. A boolean value indicating whether the encoding uses indefinite
  # length (in the case of parsing) or whether an indefinite length form shall be
  # used (in the encoding case). In DER, every value uses definite length form.
  # But in scenarios where large amounts of data need to be transferred it might
  # be desirable to have some kind of streaming support available. For example,
  # huge OCTET STRINGs are preferably sent in smaller-sized chunks, each at a
  # time. This is possible in BER by setting the length bytes of an encoding to
  # zero and by this indicating that the following value will be sent in chunks.
  # Indefinite length encodings are always constructed. The end of such a stream
  # of chunks is indicated by sending a EOC (End of Content) tag. SETs and
  # SEQUENCEs may use an indefinite length encoding, but also primitive types such
  # as e.g. OCTET STRINGS or BIT STRINGS may leverage this functionality (cf.
  # ITU-T X.690).
  #
  alias infinite_length indefinite_length

  alias infinite_length= indefinite_length=

  # An Integer representing the tag number of this ASN1Data. Never `nil`.
  #
  def tag: () -> ::Integer

  def tag=: (::Integer) -> void

  # A Symbol representing the tag class of this ASN1Data. Never `nil`. See
  # ASN1Data for possible values.
  #
  def tag_class: () -> OpenSSL::ASN1::tag_class

  def tag_class=: (OpenSSL::ASN1::tag_class) -> void

  # Encodes this ASN1Data into a DER-encoded String value. The result is
  # DER-encoded except for the possibility of indefinite length forms. Indefinite
  # length forms are not allowed in strict DER, so strictly speaking the result of
  # such an encoding would be a BER-encoding.
  #
  def to_der: () -> String

  # Carries the value of a ASN.1 type. Please confer Constructive and Primitive
  # for the mappings between ASN.1 data types and Ruby classes.
  #
  def value: () -> untyped

  def value=: (untyped) -> void

  private

  # *value*: Please have a look at Constructive and Primitive to see how Ruby
  # types are mapped to ASN.1 types and vice versa.
  #
  # *tag*: An Integer indicating the tag number.
  #
  # *tag_class*: A Symbol indicating the tag class. Please cf. ASN1 for possible
  # values.
  #
  # ## Example
  #     asn1_int = OpenSSL::ASN1Data.new(42, 2, :UNIVERSAL) # => Same as OpenSSL::ASN1::Integer.new(42)
  #     tagged_int = OpenSSL::ASN1Data.new(42, 0, :CONTEXT_SPECIFIC) # implicitly 0-tagged INTEGER
  #
  def initialize: (untyped value, ::Integer tag, OpenSSL::ASN1::tag_class tag_class) -> void
end

class OpenSSL::ASN1::EndOfContent < OpenSSL::ASN1::ASN1Data
  public

  def to_der: () -> String

  private

  def initialize: () -> void
end

# The parent class for all constructed encodings. The *value* attribute of a
# Constructive is always an Array. Attributes are the same as for ASN1Data, with
# the addition of *tagging*.
#
# ## SET and SEQUENCE
#
# Most constructed encodings come in the form of a SET or a SEQUENCE. These
# encodings are represented by one of the two sub-classes of Constructive:
# *   OpenSSL::ASN1::Set
# *   OpenSSL::ASN1::Sequence
#
# Please note that tagged sequences and sets are still parsed as instances of
# ASN1Data. Find further details on tagged values there.
#
# ### Example - constructing a SEQUENCE
#     int = OpenSSL::ASN1::Integer.new(1)
#     str = OpenSSL::ASN1::PrintableString.new('abc')
#     sequence = OpenSSL::ASN1::Sequence.new( [ int, str ] )
#
# ### Example - constructing a SET
#     int = OpenSSL::ASN1::Integer.new(1)
#     str = OpenSSL::ASN1::PrintableString.new('abc')
#     set = OpenSSL::ASN1::Set.new( [ int, str ] )
#
class OpenSSL::ASN1::Constructive < OpenSSL::ASN1::ASN1Data
  include Enumerable

  public

  # Calls the given block once for each element in self, passing that element as
  # parameter *asn1*. If no block is given, an enumerator is returned instead.
  #
  # ## Example
  #     asn1_ary.each do |asn1|
  #       puts asn1
  #     end
  #
  def each: () { (untyped asn1) -> void } -> self

  # May be used as a hint for encoding a value either implicitly or explicitly by
  # setting it either to `:IMPLICIT` or to `:EXPLICIT`. *tagging* is not set when
  # a ASN.1 structure is parsed using OpenSSL::ASN1.decode.
  #
  def tagging: () -> OpenSSL::ASN1::tagging?

  def tagging=: (OpenSSL::ASN1::tagging) -> void

  # See ASN1Data#to_der for details.
  #
  def to_der: () -> String

  private

  # *value*: is mandatory.
  #
  # *tag*: optional, may be specified for tagged values. If no *tag* is specified,
  # the UNIVERSAL tag corresponding to the Primitive sub-class is used by default.
  #
  # *tagging*: may be used as an encoding hint to encode a value either explicitly
  # or implicitly, see ASN1 for possible values.
  #
  # *tag_class*: if *tag* and *tagging* are `nil` then this is set to `:UNIVERSAL`
  # by default. If either *tag* or *tagging* are set then `:CONTEXT_SPECIFIC` is
  # used as the default. For possible values please cf. ASN1.
  #
  # ## Example
  #     int = OpenSSL::ASN1::Integer.new(42)
  #     zero_tagged_int = OpenSSL::ASN1::Integer.new(42, 0, :IMPLICIT)
  #     private_explicit_zero_tagged_int = OpenSSL::ASN1::Integer.new(42, 0, :EXPLICIT, :PRIVATE)
  #
  def initialize: (untyped value, ?::Integer tag, ?OpenSSL::ASN1::tagging tagging, ?OpenSSL::ASN1::tag_class tag_class) -> void
end

class OpenSSL::ASN1::Sequence < OpenSSL::ASN1::Constructive
end

class OpenSSL::ASN1::Set < OpenSSL::ASN1::Constructive
end

# The parent class for all primitive encodings. Attributes are the same as for
# ASN1Data, with the addition of *tagging*. Primitive values can never be
# encoded with indefinite length form, thus it is not possible to set the
# *indefinite_length* attribute for Primitive and its sub-classes.
#
# ## Primitive sub-classes and their mapping to Ruby classes
# *   OpenSSL::ASN1::EndOfContent    <=> *value* is always `nil`
# *   OpenSSL::ASN1::Boolean         <=> *value* is `true` or `false`
# *   OpenSSL::ASN1::Integer         <=> *value* is an OpenSSL::BN
# *   OpenSSL::ASN1::BitString       <=> *value* is a String
# *   OpenSSL::ASN1::OctetString     <=> *value* is a String
# *   OpenSSL::ASN1::Null            <=> *value* is always `nil`
# *   OpenSSL::ASN1::Object          <=> *value* is a String
# *   OpenSSL::ASN1::Enumerated      <=> *value* is an OpenSSL::BN
# *   OpenSSL::ASN1::UTF8String      <=> *value* is a String
# *   OpenSSL::ASN1::NumericString   <=> *value* is a String
# *   OpenSSL::ASN1::PrintableString <=> *value* is a String
# *   OpenSSL::ASN1::T61String       <=> *value* is a String
# *   OpenSSL::ASN1::VideotexString  <=> *value* is a String
# *   OpenSSL::ASN1::IA5String       <=> *value* is a String
# *   OpenSSL::ASN1::UTCTime         <=> *value* is a Time
# *   OpenSSL::ASN1::GeneralizedTime <=> *value* is a Time
# *   OpenSSL::ASN1::GraphicString   <=> *value* is a String
# *   OpenSSL::ASN1::ISO64String     <=> *value* is a String
# *   OpenSSL::ASN1::GeneralString   <=> *value* is a String
# *   OpenSSL::ASN1::UniversalString <=> *value* is a String
# *   OpenSSL::ASN1::BMPString       <=> *value* is a String
#
#
# ## OpenSSL::ASN1::BitString
#
# ### Additional attributes
# *unused_bits*: if the underlying BIT STRING's length is a multiple of 8 then
# *unused_bits* is 0. Otherwise *unused_bits* indicates the number of bits that
# are to be ignored in the final octet of the BitString's *value*.
#
# ## OpenSSL::ASN1::ObjectId
#
# NOTE: While OpenSSL::ASN1::ObjectId.new will allocate a new ObjectId, it is
# not typically allocated this way, but rather that are received from parsed
# ASN1 encodings.
#
# ### Additional attributes
# *   *sn*: the short name as defined in <openssl/objects.h>.
# *   *ln*: the long name as defined in <openssl/objects.h>.
# *   *oid*: the object identifier as a String, e.g. "1.2.3.4.5"
# *   *short_name*: alias for *sn*.
# *   *long_name*: alias for *ln*.
#
#
# ## Examples
# With the Exception of OpenSSL::ASN1::EndOfContent, each Primitive class
# constructor takes at least one parameter, the *value*.
#
# ### Creating EndOfContent
#     eoc = OpenSSL::ASN1::EndOfContent.new
#
# ### Creating any other Primitive
#     prim = <class>.new(value) # <class> being one of the sub-classes except EndOfContent
#     prim_zero_tagged_implicit = <class>.new(value, 0, :IMPLICIT)
#     prim_zero_tagged_explicit = <class>.new(value, 0, :EXPLICIT)
#
class OpenSSL::ASN1::Primitive < OpenSSL::ASN1::ASN1Data
  public

  # May be used as a hint for encoding a value either implicitly or explicitly by
  # setting it either to `:IMPLICIT` or to `:EXPLICIT`. *tagging* is not set when
  # a ASN.1 structure is parsed using OpenSSL::ASN1.decode.
  #
  def tagging: () -> OpenSSL::ASN1::tagging?


  def tagging=: (OpenSSL::ASN1::tagging) -> void

  # See ASN1Data#to_der for details.
  #
  def to_der: () -> String

  private

  # *value*: is mandatory.
  #
  # *tag*: optional, may be specified for tagged values. If no *tag* is specified,
  # the UNIVERSAL tag corresponding to the Primitive sub-class is used by default.
  #
  # *tagging*: may be used as an encoding hint to encode a value either explicitly
  # or implicitly, see ASN1 for possible values.
  #
  # *tag_class*: if *tag* and *tagging* are `nil` then this is set to `:UNIVERSAL`
  # by default. If either *tag* or *tagging* are set then `:CONTEXT_SPECIFIC` is
  # used as the default. For possible values please cf. ASN1.
  #
  # ## Example
  #     int = OpenSSL::ASN1::Integer.new(42)
  #     zero_tagged_int = OpenSSL::ASN1::Integer.new(42, 0, :IMPLICIT)
  #     private_explicit_zero_tagged_int = OpenSSL::ASN1::Integer.new(42, 0, :EXPLICIT, :PRIVATE)
  #
  def initialize: (untyped value, ?::Integer tag, ?OpenSSL::ASN1::tagging tagging, ?OpenSSL::ASN1::tag_class tag_class) -> void
end

class OpenSSL::ASN1::BMPString < OpenSSL::ASN1::Primitive
end

class OpenSSL::ASN1::BitString < OpenSSL::ASN1::Primitive
  public

  def unused_bits: () -> ::Integer?


  def unused_bits=: (::Integer) -> void
end

class OpenSSL::ASN1::Boolean < OpenSSL::ASN1::Primitive
end

class OpenSSL::ASN1::Enumerated < OpenSSL::ASN1::Primitive
end

class OpenSSL::ASN1::GeneralString < OpenSSL::ASN1::Primitive
end

class OpenSSL::ASN1::GeneralizedTime < OpenSSL::ASN1::Primitive
end

class OpenSSL::ASN1::GraphicString < OpenSSL::ASN1::Primitive
end

class OpenSSL::ASN1::IA5String < OpenSSL::ASN1::Primitive
end

class OpenSSL::ASN1::ISO64String < OpenSSL::ASN1::Primitive
end

class OpenSSL::ASN1::Integer < OpenSSL::ASN1::Primitive
end

class OpenSSL::ASN1::Null < OpenSSL::ASN1::Primitive
end

class OpenSSL::ASN1::NumericString < OpenSSL::ASN1::Primitive
end

# Represents the primitive object id for OpenSSL::ASN1
#
class OpenSSL::ASN1::ObjectId < OpenSSL::ASN1::Primitive
  # This adds a new ObjectId to the internal tables. Where *object_id* is the
  # numerical form, *short_name* is the short name, and *long_name* is the long
  # name.
  #
  # Returns `true` if successful. Raises an OpenSSL::ASN1::ASN1Error if it fails.
  #
  def self.register: (String object_id, String short_name, String long_name) -> TrueClass

  public

  # The long name of the ObjectId, as defined in <openssl/objects.h>.
  #
  def ln: () -> String?

  alias long_name ln

  # Returns a String representing the Object Identifier in the dot notation, e.g.
  # "1.2.3.4.5"
  #
  def oid: () -> String

  alias short_name sn

  # The short name of the ObjectId, as defined in <openssl/objects.h>.
  #
  def sn: () -> String?
end

class OpenSSL::ASN1::OctetString < OpenSSL::ASN1::Primitive
end

class OpenSSL::ASN1::PrintableString < OpenSSL::ASN1::Primitive
end

class OpenSSL::ASN1::T61String < OpenSSL::ASN1::Primitive
end

class OpenSSL::ASN1::UTCTime < OpenSSL::ASN1::Primitive
end

class OpenSSL::ASN1::UTF8String < OpenSSL::ASN1::Primitive
end

class OpenSSL::ASN1::UniversalString < OpenSSL::ASN1::Primitive
end

class OpenSSL::ASN1::VideotexString < OpenSSL::ASN1::Primitive
end
